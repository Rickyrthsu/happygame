<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>俄羅斯方塊 (AI 演算法修正版)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans TC', sans-serif;
            touch-action: manipulation;
        }
        .game-canvas {
            border: 4px solid #334155;
            border-radius: 8px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23);
        }
        .btn-control {
            transition: all 0.2s ease-in-out;
        }
        .btn-control:active {
            transform: scale(0.95);
            background-color: #475569;
        }
        /* AI 開關樣式 */
        .switch { position: relative; display: inline-block; width: 60px; height: 34px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #4b5563; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #4f46e5; }
        input:checked + .slider:before { transform: translateX(26px); }
    </style>
</head>
<body class="bg-slate-800 text-white flex flex-col items-center justify-center min-h-screen p-4">

    <h1 class="text-4xl font-bold mb-4 tracking-wider">俄羅斯方塊</h1>

    <div class="flex flex-col md:flex-row items-center md:items-start justify-center gap-6 w-full max-w-5xl">
        
        <!-- 遊戲主體 + 手機按鈕的容器 -->
        <div class="flex flex-row items-start gap-4">
            <!-- 遊戲主區域 -->
            <div class="relative">
                <canvas id="tetris" class="game-canvas"></canvas>
                <!-- 遊戲結束畫面 -->
                <div id="gameOverScreen" class="absolute inset-0 bg-black bg-opacity-75 flex-col items-center justify-center text-center hidden">
                    <h2 class="text-4xl font-bold text-red-500 mb-4">遊戲結束</h2>
                    <p class="text-xl mb-6">您的分數: <span id="finalScore">0</span></p>
                    <button id="restartButton" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition-colors">重新開始 (R)</button>
                </div>
                <!-- 暫停畫面 -->
                <div id="pauseScreen" class="absolute inset-0 bg-black bg-opacity-75 flex-col items-center justify-center text-center hidden">
                    <h2 class="text-4xl font-bold text-blue-400 mb-4">已暫停</h2>
                    <p class="text-lg">按下 'P' 鍵繼續</p>
                </div>
            </div>

            <!-- 手機操作按鈕 (移至右側) -->
            <div id="manualControls" class="flex flex-col items-center justify-around h-full md:hidden" style="height: 600px;">
                <button id="rotateBtn" class="btn-control bg-slate-600 rounded-full w-16 h-16 flex items-center justify-center text-2xl font-bold">↻</button>
                <button id="leftBtn" class="btn-control bg-slate-600 rounded-full w-16 h-16 flex items-center justify-center text-2xl font-bold">←</button>
                <button id="rightBtn" class="btn-control bg-slate-600 rounded-full w-16 h-16 flex items-center justify-center text-2xl font-bold">→</button>
                <button id="downBtn" class="btn-control bg-slate-600 rounded-full w-16 h-16 flex items-center justify-center text-2xl font-bold">↓</button>
                <button id="hardDropBtn" class="btn-control bg-slate-600 rounded-lg w-full h-16 flex items-center justify-center text-md font-bold">落下</button>
            </div>
        </div>


        <!-- 遊戲資訊和控制 -->
        <div class="w-full md:w-48 flex flex-col gap-4">
            <div class="bg-slate-700 p-4 rounded-lg shadow-lg text-center">
                <h2 class="text-xl font-bold mb-2">歷史最高分</h2>
                <p id="highScore" class="text-3xl font-mono">0</p>
            </div>
            <div class="bg-slate-700 p-4 rounded-lg shadow-lg text-center">
                <h2 class="text-xl font-bold mb-2">分數</h2>
                <p id="score" class="text-3xl font-mono">0</p>
            </div>
            <div class="bg-slate-700 p-4 rounded-lg shadow-lg text-center">
                <h2 class="text-xl font-bold mb-2">下一個</h2>
                <canvas id="next" width="120" height="120"></canvas>
            </div>
            <div class="bg-slate-700 p-4 rounded-lg shadow-lg text-center">
                <h2 class="text-xl font-bold mb-2">AI 模式</h2>
                <label class="switch">
                    <input type="checkbox" id="aiToggle">
                    <span class="slider"></span>
                </label>
            </div>
            <!-- 新增：AI 速度控制 -->
            <div id="aiSpeedControl" class="bg-slate-700 p-4 rounded-lg shadow-lg text-center hidden">
                <h2 class="text-xl font-bold mb-2">AI 速度</h2>
                <input type="range" id="aiSpeedSlider" min="0" max="500" value="100" class="w-full">
                <span id="aiSpeedLabel" class="text-sm font-mono">100 ms</span>
            </div>
        </div>
    </div>

    <!-- 新增：返回按鈕 -->
    <a href="./index.html" class="fixed bottom-5 right-5 bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg transition-colors z-10">
        返回
    </a>

    <script>
        // --- 遊戲基本設定 ---
        const canvas = document.getElementById('tetris');
        const context = canvas.getContext('2d');
        const nextCanvas = document.getElementById('next');
        const nextContext = nextCanvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('highScore');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreElement = document.getElementById('finalScore');
        const restartButton = document.getElementById('restartButton');
        const aiToggle = document.getElementById('aiToggle');
        const manualControls = document.getElementById('manualControls');
        const pauseScreen = document.getElementById('pauseScreen');
        const aiSpeedControl = document.getElementById('aiSpeedControl');
        const aiSpeedSlider = document.getElementById('aiSpeedSlider');
        const aiSpeedLabel = document.getElementById('aiSpeedLabel');

        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30;
        const NEXT_BLOCK_SIZE = 20;

        canvas.width = COLS * BLOCK_SIZE;
        canvas.height = ROWS * BLOCK_SIZE;
        context.scale(BLOCK_SIZE, BLOCK_SIZE);
        nextContext.scale(NEXT_BLOCK_SIZE, NEXT_BLOCK_SIZE);

        const COLORS = [ null, '#C792EA', '#FFCB6B', '#F78C6C', '#82AAFF', '#89DDFF', '#C3E88D', '#FF5370' ];
        const SHAPES = [ [], [[0, 1, 0], [1, 1, 1], [0, 0, 0]], [[1, 1], [1, 1]], [[0, 0, 1], [1, 1, 1], [0, 0, 0]], [[1, 0, 0], [1, 1, 1], [0, 0, 0]], [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]], [[0, 1, 1], [1, 1, 0], [0, 0, 0]], [[1, 1, 0], [0, 1, 1], [0, 0, 0]] ];

        let board, player, nextPiece, score, highScore, dropCounter, dropInterval, lastTime, isGameOver;
        let isAiActive = false;
        let isPaused = false;

        // --- AI 相關設定 ---
        let AI_MOVE_DELAY = 100;
        let lastAiMoveTime = 0;
        
        const AI_WEIGHTS = {
            clearedLines: 500,
            tetrisBonus: 2000,
            aggregateHeight: -10,
            holes: -700,
            bumpiness: -50
        };

        // --- 核心遊戲邏輯 ---
        function createBoard() { return Array.from({ length: ROWS }, () => Array(COLS).fill(0)); }
        function drawBlock(ctx, x, y, color, size = 1) { ctx.fillStyle = color; ctx.fillRect(x, y, size, size); ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 0.1; ctx.strokeRect(x, y, size, size); }
        
        /**
         * 新增：繪製預判落點的鬼影方塊
         */
        function drawGhostPiece() {
            if (isGameOver || isPaused || !player.matrix) return;

            // 複製當前方塊來計算落點
            const ghostPlayer = JSON.parse(JSON.stringify(player));

            // 持續下移直到碰撞
            while (!collide(ghostPlayer, board)) {
                ghostPlayer.pos.y++;
            }
            // 移回碰撞前的最後一個有效位置
            ghostPlayer.pos.y--;

            // 繪製半透明的鬼影
            const color = COLORS[ghostPlayer.typeId];
            context.globalAlpha = 0.3; // 設定透明度
            ghostPlayer.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        // 只畫邊框，更有虛線框的感覺
                        context.fillStyle = color;
                        context.fillRect(ghostPlayer.pos.x + x, ghostPlayer.pos.y + y, 1, 1);
                    }
                });
            });
            context.globalAlpha = 1.0; // 重置透明度
        }

        function draw() { 
            context.fillStyle = '#1e293b'; 
            context.fillRect(0, 0, canvas.width, canvas.height); 
            
            context.strokeStyle = 'rgba(128, 128, 128, 0.2)'; 
            context.lineWidth = 0.05; 
            for (let x = 1; x < COLS; x++) { context.beginPath(); context.moveTo(x, 0); context.lineTo(x, ROWS); context.stroke(); } 
            for (let y = 1; y < ROWS; y++) { context.beginPath(); context.moveTo(0, y); context.lineTo(COLS, y); context.stroke(); } 
            
            board.forEach((row, y) => row.forEach((value, x) => { if (value !== 0) drawBlock(context, x, y, COLORS[value]); })); 
            
            // 在繪製活動方塊前，先繪製鬼影
            drawGhostPiece();

            if (player.matrix) { 
                player.matrix.forEach((row, y) => row.forEach((value, x) => { 
                    if (value !== 0) drawBlock(context, player.pos.x + x, player.pos.y + y, COLORS[player.typeId]); 
                })); 
            } 
        }

        function drawNext() { nextContext.fillStyle = '#1e293b'; nextContext.fillRect(0, 0, nextCanvas.width, nextCanvas.height); if (nextPiece && nextPiece.matrix) { const m = nextPiece.matrix; const ox = (6 - m[0].length) / 2; const oy = (6 - m.length) / 2; m.forEach((row, y) => row.forEach((value, x) => { if (value !== 0) drawBlock(nextContext, x + ox, y + oy, COLORS[nextPiece.typeId], 1); })); } }
        function collide(player, board) { const [m, o] = [player.matrix, player.pos]; for (let y = 0; y < m.length; ++y) { for (let x = 0; x < m[y].length; ++x) { if (m[y][x] !== 0 && (board[y + o.y] && board[y + o.y][x + o.x]) !== 0) return true; } } return false; }
        function merge(player, board) { player.matrix.forEach((row, y) => row.forEach((value, x) => { if (value !== 0) board[y + player.pos.y][x + player.pos.x] = value; })); }
        function rotate(matrix, dir) { for (let y = 0; y < matrix.length; ++y) { for (let x = 0; x < y; ++x) { [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]]; } } if (dir > 0) matrix.forEach(row => row.reverse()); else matrix.reverse(); }
        function playerDrop() { if (isPaused) return; player.pos.y++; if (collide(player, board)) { player.pos.y--; merge(player, board); sweepLines(); playerReset(); } dropCounter = 0; }
        function playerHardDrop() { if (isPaused) return; while (!collide(player, board)) { player.pos.y++; } player.pos.y--; merge(player, board); sweepLines(); playerReset(); dropCounter = 0; }
        function playerMove(dir) { if (isGameOver || isAiActive || isPaused) return; player.pos.x += dir; if (collide(player, board)) player.pos.x -= dir; }
        function playerRotate(dir) { if (isGameOver || isAiActive || isPaused) return; const pos = player.pos.x; let offset = 1; rotate(player.matrix, dir); while (collide(player, board)) { player.pos.x += offset; offset = -(offset + (offset > 0 ? 1 : -1)); if (offset > player.matrix[0].length) { rotate(player.matrix, -dir); player.pos.x = pos; return; } } }
        function createPiece(type) { let matrix, typeId; if (type === 'T') { matrix = SHAPES[1]; typeId = 1; } else if (type === 'O') { matrix = SHAPES[2]; typeId = 2; } else if (type === 'L') { matrix = SHAPES[3]; typeId = 3; } else if (type === 'J') { matrix = SHAPES[4]; typeId = 4; } else if (type === 'I') { matrix = SHAPES[5]; typeId = 5; } else if (type === 'S') { matrix = SHAPES[6]; typeId = 6; } else if (type === 'Z') { matrix = SHAPES[7]; typeId = 7; } return { pos: { x: 0, y: 0 }, matrix: matrix, typeId: typeId }; }
        function updateHighScore() { if (score > highScore) { highScore = score; localStorage.setItem('tetrisHighScore', highScore); highScoreElement.innerText = highScore; } }
        function handleGameOver() { isGameOver = true; updateHighScore(); gameOverScreen.classList.remove('hidden'); gameOverScreen.classList.add('flex'); finalScoreElement.innerText = score; }
        function playerReset() { const pieces = 'TJLOISZ'; player = nextPiece || createPiece(pieces[pieces.length * Math.random() | 0]); nextPiece = createPiece(pieces[pieces.length * Math.random() | 0]); player.pos.y = 0; player.pos.x = (COLS / 2 | 0) - (player.matrix[0].length / 2 | 0); if (collide(player, board)) { handleGameOver(); } drawNext(); }
        function sweepLines() { let clearedLines = 0; outer: for (let y = board.length - 1; y > 0; --y) { for (let x = 0; x < board[y].length; ++x) { if (board[y][x] === 0) continue outer; } const row = board.splice(y, 1)[0].fill(0); board.unshift(row); y++; clearedLines++; } if (clearedLines > 0) { const lineScores = [0, 40, 100, 300, 1200]; score += lineScores[clearedLines]; scoreElement.innerText = score; } }

        // --- AI 核心演算法 (已還原) ---
        function evaluateBoard(board) {
            let score = 0;
            const columnHeights = Array(COLS).fill(0);
            let holes = 0;
            let clearedLines = 0;

            for (let y = 0; y < ROWS; y++) {
                let isLineFull = true;
                for (let x = 0; x < COLS; x++) {
                    if (board[y][x] === 0) {
                        isLineFull = false;
                        if (y > 0) {
                            let blockAbove = false;
                            for(let k = y - 1; k >= 0; k--) {
                                if (board[k][x] !== 0) {
                                    blockAbove = true;
                                    break;
                                }
                            }
                            if (blockAbove) holes++;
                        }
                    } else {
                        if (columnHeights[x] === 0) {
                            columnHeights[x] = ROWS - y;
                        }
                    }
                }
                if (isLineFull) {
                    clearedLines++;
                }
            }

            const aggregateHeight = columnHeights.reduce((a, b) => a + b, 0);
            let bumpiness = 0;
            for (let i = 0; i < COLS - 1; i++) {
                bumpiness += Math.abs(columnHeights[i] - columnHeights[i+1]);
            }

            score += clearedLines * AI_WEIGHTS.clearedLines;
            if (clearedLines === 4) {
                score += AI_WEIGHTS.tetrisBonus;
            }
            score += aggregateHeight * AI_WEIGHTS.aggregateHeight;
            score += holes * AI_WEIGHTS.holes;
            score += bumpiness * AI_WEIGHTS.bumpiness;
            
            return score;
        }

        function findBestMove() {
            let bestScore = -Infinity;
            let bestMove = null;
            const originalPlayer = JSON.parse(JSON.stringify(player));

            for (let rotation = 0; rotation < 4; rotation++) {
                let tempPlayerForRotation = JSON.parse(JSON.stringify(originalPlayer));
                for(let i = 0; i < rotation; i++) rotate(tempPlayerForRotation.matrix, 1);
                if (rotation > 0 && JSON.stringify(tempPlayerForRotation.matrix) === JSON.stringify(originalPlayer.matrix)) continue;

                for (let x = -2; x < COLS; x++) {
                    let tempBoard = JSON.parse(JSON.stringify(board));
                    let tempPlayer = JSON.parse(JSON.stringify(tempPlayerForRotation));
                    tempPlayer.pos.x = x;

                    if (collide(tempPlayer, tempBoard)) continue;

                    while (!collide(tempPlayer, tempBoard)) {
                        tempPlayer.pos.y++;
                    }
                    tempPlayer.pos.y--;

                    if (tempPlayer.pos.y < 0) continue;

                    merge(tempPlayer, tempBoard);
                    
                    const score = evaluateBoard(tempBoard);

                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = { rotation: rotation, x: x };
                    }
                }
            }
            return bestMove;
        }


        function executeAiMove() { const bestMove = findBestMove(); if (bestMove) { for (let i = 0; i < bestMove.rotation; i++) { rotate(player.matrix, 1); } player.pos.x = bestMove.x; playerHardDrop(); } else { playerHardDrop(); } }
        function togglePause() { if (isGameOver) return; isPaused = !isPaused; if (isPaused) { pauseScreen.classList.remove('hidden'); pauseScreen.classList.add('flex'); } else { pauseScreen.classList.add('hidden'); pauseScreen.classList.remove('flex'); lastTime = performance.now(); } }
        function update(time = 0) { if (isGameOver) return; if (!isPaused) { const deltaTime = time - lastTime; lastTime = time; if (isAiActive) { if (time - lastAiMoveTime > AI_MOVE_DELAY) { executeAiMove(); lastAiMoveTime = time; } } else { dropCounter += deltaTime; if (dropCounter > dropInterval) { playerDrop(); } } draw(); } requestAnimationFrame(update); }
        function startGame() { board = createBoard(); score = 0; highScore = localStorage.getItem('tetrisHighScore') || 0; scoreElement.innerText = score; highScoreElement.innerText = highScore; dropInterval = 1000; isGameOver = false; isPaused = false; lastTime = 0; dropCounter = 0; lastAiMoveTime = 0; playerReset(); if (!isPaused) { update(); } }
        function restartGame() { if (isGameOver) { gameOverScreen.classList.add('hidden'); gameOverScreen.classList.remove('flex'); } else { updateHighScore(); } isGameOver = true; pauseScreen.classList.add('hidden'); pauseScreen.classList.remove('flex'); setTimeout(startGame, 0); }
        
        // --- 事件監聽 ---
        document.addEventListener('keydown', event => { const key = event.key.toLowerCase(); if (key === 'p') { togglePause(); return; } if (key === 'r') { restartGame(); return; } if (isGameOver || isAiActive || isPaused) return; if (event.key === 'ArrowLeft') playerMove(-1); else if (event.key === 'ArrowRight') playerMove(1); else if (event.key === 'ArrowDown') playerDrop(); else if (event.key === 'ArrowUp') playerRotate(1); else if (event.code === 'Space' || event.key === ' ') { event.preventDefault(); playerHardDrop(); } });
        restartButton.addEventListener('click', restartGame);
        
        aiToggle.addEventListener('change', (e) => {
            isAiActive = e.target.checked;
            manualControls.style.display = isAiActive ? 'none' : 'flex';
            if (isAiActive) {
                aiSpeedControl.classList.remove('hidden');
            } else {
                aiSpeedControl.classList.add('hidden');
                dropCounter = 0;
                lastTime = performance.now();
            }
        });

        // 新增：AI 速度滑桿事件
        aiSpeedSlider.addEventListener('input', (e) => {
            AI_MOVE_DELAY = parseInt(e.target.value);
            aiSpeedLabel.innerText = `${AI_MOVE_DELAY} ms`;
        });

        document.getElementById('leftBtn')?.addEventListener('click', () => playerMove(-1));
        document.getElementById('rightBtn')?.addEventListener('click', () => playerMove(1));
        document.getElementById('downBtn')?.addEventListener('click', () => playerDrop());
        document.getElementById('rotateBtn')?.addEventListener('click', () => playerRotate(1));
        document.getElementById('hardDropBtn')?.addEventListener('click', () => playerHardDrop());
        
        // 初始啟動
        startGame();
    </script>
</body>
</html>
