<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>é€²åŒ–è¥¿ç“œï¼åˆæˆåœ“çƒéŠæˆ²</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body {
            background: linear-gradient(135deg, #fdfbfb 0%, #ebedee 100%);
            height: 100dvh; 
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        #main-layout {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 20px;
            width: 100%;
            height: 100%;
            padding: 15px;
            box-sizing: border-box;
            max-width: 1200px;
            margin: 0 auto;
        }

        /* å·¦å´åœ–é‘‘é¢æ¿ */
        #guide-panel {
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.08);
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 90vh;
            overflow-y: auto;
            border: 2px solid #fff;
            min-width: 160px;
            z-index: 10;
        }

        .guide-title {
            text-align: center;
            font-weight: bold;
            color: #555;
            margin-bottom: 10px;
            font-size: 1.1rem;
            border-bottom: 2px dashed #eee;
            padding-bottom: 8px;
        }

        .guide-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px 10px;
            border-radius: 10px;
            background: #f8f9fa;
        }

        .guide-icon {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            box-shadow: inset -2px -2px 6px rgba(0,0,0,0.15), 0 2px 4px rgba(0,0,0,0.1);
        }

        /* éŠæˆ²èˆ‡ UI çš„æ¬„ä½ */
        #game-column {
            display: flex;
            flex-direction: column;
            gap: 10px;
            height: 100%;
            width: 100%;
            max-width: 500px; 
            justify-content: center;
        }

        /* ç¨ç«‹é ‚éƒ¨ UI å€å¡Š */
        #top-ui-bar {
            display: flex;
            justify-content: space-between;
            align-items: stretch;
            gap: 10px;
            width: 100%;
            flex-shrink: 0;
            z-index: 10;
        }

        .status-box {
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 15px;
            border-radius: 15px;
            box-shadow: 0 6px 15px rgba(0,0,0,0.08);
            border: 2px solid #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
        }

        .next-preview-title { font-size: 0.75rem; color: #888; font-weight: bold; margin-bottom: 2px; }
        #next-ball-preview { font-size: 2rem; filter: drop-shadow(0 4px 4px rgba(0,0,0,0.1)); line-height: 1; }

        .high-score-text { font-size: 0.7rem; color: #aaa; margin-bottom: 0px; font-weight: bold; letter-spacing: 1px; }
        .current-score { font-size: 1.5rem; font-weight: 900; color: #ff5252; display: flex; align-items: center; gap: 5px; line-height: 1.2; }

        /* éŠæˆ²å€åŸŸå®¹å™¨ */
        #game-wrapper {
            position: relative;
            width: 100%;
            flex-grow: 1;
            min-height: 0; 
            background-color: #ffe8cc;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            overflow: hidden;
            border: 4px solid #fff;
            touch-action: none; 
            cursor: crosshair;
        }

        canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
            object-fit: contain; 
        }

        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
        }

        #game-over-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s;
            backdrop-filter: blur(4px);
        }

        #game-over-screen.active {
            opacity: 1;
            pointer-events: auto;
            z-index: 50;
        }

        @media (max-width: 768px) {
            #main-layout { flex-direction: column; padding: 10px; gap: 8px; }
            #guide-panel {
                flex-direction: row; width: 100%; overflow-x: auto; padding: 8px; border-radius: 12px; min-width: 0;
            }
            .guide-title, .guide-item span { display: none; }
            .guide-item { padding: 4px; }
            #game-column { height: 0; flex-grow: 1; }
        }
    </style>
</head>
<body>

<div id="main-layout">
    <div id="guide-panel">
        <div class="guide-title">é€²åŒ–åœ–é‘‘</div>
    </div>

    <div id="game-column">
        <div id="top-ui-bar">
            <div class="status-box">
                <div class="next-preview-title">NEXT</div>
                <div id="next-ball-preview">â“</div>
            </div>
            <div class="status-box">
                <div class="high-score-text">BEST: <span id="high-score">0</span></div>
                <div class="current-score">ğŸ† <span id="score">0</span></div>
            </div>
        </div>

        <div id="game-wrapper">
            <div id="ui-layer"></div>
            
            <div id="game-over-screen">
                <h1 class="text-4xl font-black mb-2 text-white drop-shadow-[0_0_15px_rgba(255,100,100,0.8)]">GAME OVER</h1>
                <div class="bg-white text-gray-800 px-8 py-4 rounded-2xl mb-6 shadow-2xl text-center">
                    <p class="text-xs font-bold text-gray-400 mb-1">FINAL SCORE</p>
                    <p id="final-score" class="text-4xl font-black text-red-500">0</p>
                </div>
                <button id="restart-btn" class="px-8 py-3 bg-gradient-to-r from-red-500 to-pink-500 text-white rounded-full font-black text-lg shadow-lg active:scale-95 transition-transform z-50">
                    å†ä¾†ä¸€å±€
                </button>
            </div>
        </div>
    </div>
</div>

<script>
    // --- 1. éŠæˆ²è¨­å®š ---
    const BALLS = [
        { level: 0, radius: 18, color: '#ff7b7b', emoji: 'ğŸ’', name: 'æ«»æ¡ƒ' },
        { level: 1, radius: 26, color: '#ffb347', emoji: 'ğŸŠ', name: 'æ©˜å­' },
        { level: 2, radius: 36, color: '#ffdf00', emoji: 'ğŸ‹', name: 'æª¸æª¬' },
        { level: 3, radius: 48, color: '#88d8b0', emoji: 'ğŸ¥', name: 'å¥‡ç•°æœ' },
        { level: 4, radius: 60, color: '#ff9a9e', emoji: 'ğŸ…', name: 'ç•ªèŒ„' },
        { level: 5, radius: 74, color: '#ff6a88', emoji: 'ğŸ', name: 'è˜‹æœ' },
        { level: 6, radius: 84, color: '#f6e58d', emoji: 'ğŸ', name: 'æ¢¨å­' }, // å¾æ¢¨å­é–‹å§‹ç¸®å°å°ºå¯¸å¹…åº¦
        { level: 7, radius: 95, color: '#f8a5c2', emoji: 'ğŸ‘', name: 'æ°´èœœæ¡ƒ' },
        { level: 8, radius: 107, color: '#f9ca24', emoji: 'ğŸ', name: 'é³³æ¢¨' },
        { level: 9, radius: 120, color: '#badc58', emoji: 'ğŸˆ', name: 'å“ˆå¯†ç“œ' },
        { level: 10, radius: 135, color: '#6ab04c', emoji: 'ğŸ‰', name: 'å¤§è¥¿ç“œ' } // æœ€çµ‚è¥¿ç“œå¤§å¹…ç¸®æ°´ï¼Œæ›´å¥½åˆï¼
    ];

    const GAME_WIDTH = 500; 
    const GAME_HEIGHT = 750;
    const GAME_OVER_LINE_Y = 130; 
    const DROP_Y = 50; 

    let particles = [];
    let floatingTexts = [];

    function spawnParticles(x, y, color, count) {
        for(let i = 0; i < count; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 12,
                vy: (Math.random() - 0.5) * 12,
                life: 1.0, color: color, size: Math.random() * 5 + 3
            });
        }
    }

    function spawnFloatingText(x, y, text, color) {
        floatingTexts.push({ x: x, y: y, text: text, life: 1.0, vy: -2, color: color });
    }

    const guidePanel = document.getElementById('guide-panel');
    BALLS.forEach(ball => {
        const item = document.createElement('div');
        item.className = 'guide-item';
        const iconSize = 24 + ball.level * 1.5; 
        item.innerHTML = `
            <div class="guide-icon" style="background-color: ${ball.color}; width: ${iconSize}px; height: ${iconSize}px; font-size: ${iconSize * 0.55}px;">
                ${ball.emoji}
            </div>
            <span class="text-sm font-bold text-gray-700">${ball.name}</span>
        `;
        guidePanel.appendChild(item);
    });

    // --- 2. ç‰©ç†å¼•æ“åˆå§‹åŒ– ---
    const Engine = Matter.Engine, Render = Matter.Render, Runner = Matter.Runner, Bodies = Matter.Bodies, Composite = Matter.Composite, Events = Matter.Events;

    let engine = Engine.create();
    let world = engine.world;
    engine.world.gravity.y = 0.7; 

    let render = Render.create({
        element: document.getElementById('game-wrapper'),
        engine: engine,
        options: { width: GAME_WIDTH, height: GAME_HEIGHT, wireframes: false, background: 'transparent' }
    });

    Render.run(render);
    let runner = Runner.create();
    Runner.run(runner, engine);

    // --- 3. éŠæˆ²ç‹€æ…‹ ---
    let score = 0;
    let highScore = localStorage.getItem('suikaHighScore') || 0;
    let isGameOver = false;
    let canDrop = true; 
    let currentBallLevel = 0;
    let nextBallLevel = 0;
    
    let isAiming = false; 
    let logicalMouseX = GAME_WIDTH / 2; 

    document.getElementById('high-score').innerText = highScore;

    const wallOptions = { isStatic: true, render: { visible: false } };
    const ground = Bodies.rectangle(GAME_WIDTH / 2, GAME_HEIGHT + 90, GAME_WIDTH * 2, 200, wallOptions);
    const leftWall = Bodies.rectangle(-50, GAME_HEIGHT / 2, 100, GAME_HEIGHT * 3, wallOptions);
    const rightWall = Bodies.rectangle(GAME_WIDTH + 50, GAME_HEIGHT / 2, 100, GAME_HEIGHT * 3, wallOptions);
    Composite.add(world, [ground, leftWall, rightWall]);

    // --- 4. æ ¸å¿ƒé‚è¼¯ ---
    function getRandomSpawnLevel() { return Math.floor(Math.random() * 4); }

    function prepareNextBall() {
        currentBallLevel = nextBallLevel;
        nextBallLevel = getRandomSpawnLevel();
        const preview = document.getElementById('next-ball-preview');
        preview.style.transform = 'scale(0.1)';
        preview.innerText = BALLS[nextBallLevel].emoji;
        setTimeout(() => preview.style.transform = 'scale(1)', 50);
        preview.style.transition = 'transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
        canDrop = true;
    }

    function dropBall() {
        if (!canDrop || isGameOver) return;
        canDrop = false;

        const ballInfo = BALLS[currentBallLevel];
        const safeX = Math.max(ballInfo.radius, Math.min(GAME_WIDTH - ballInfo.radius, logicalMouseX));

        const body = Bodies.circle(safeX, DROP_Y, ballInfo.radius, {
            restitution: 0.25, friction: 0.5, frictionAir: 0.015,
            density: 0.005 + (currentBallLevel * 0.001), 
            render: { visible: false }, 
            label: 'circle', level: currentBallLevel, isMerging: false, renderScale: 1 
        });

        Composite.add(world, body);
        setTimeout(() => { if(!isGameOver) prepareNextBall(); }, 700);
    }

    function updateScore(add) {
        score += add;
        const scoreEl = document.getElementById('score');
        scoreEl.innerText = score;
        scoreEl.style.transform = 'scale(1.4)';
        setTimeout(() => { scoreEl.style.transform = 'scale(1)'; scoreEl.style.transition = 'all 0.2s'; }, 150);
        
        if (score > highScore) {
            highScore = score;
            localStorage.setItem('suikaHighScore', highScore);
            document.getElementById('high-score').innerText = highScore;
        }
    }

    function triggerGameOver() {
        isGameOver = true;
        canDrop = false;
        isAiming = false;
        document.getElementById('game-over-screen').classList.add('active');
        document.getElementById('final-score').innerText = score;
    }

    function resetGame() {
        const bodies = Composite.allBodies(world).filter(b => b.label === 'circle');
        Composite.remove(world, bodies);
        score = 0; updateScore(0);
        isGameOver = false; isAiming = false;
        particles = []; floatingTexts = [];
        document.getElementById('game-over-screen').classList.remove('active');
        nextBallLevel = getRandomSpawnLevel();
        prepareNextBall();
    }

    // --- 5. äº‹ä»¶ç›£è½ (é€£é–é˜²å¡æ­»èˆ‡åˆä½µ) ---
    Events.on(engine, 'collisionStart', (event) => {
        event.pairs.sort((a, b) => {
            const yA = Math.max(a.bodyA.position.y, a.bodyB.position.y);
            const yB = Math.max(b.bodyA.position.y, b.bodyB.position.y);
            return yB - yA;
        });

        event.pairs.forEach((collision) => {
            const bodyA = collision.bodyA, bodyB = collision.bodyB;

            if (bodyA.label === 'circle' && bodyB.label === 'circle' && bodyA.level === bodyB.level) {
                if (bodyA.isMerging || bodyB.isMerging) return;
                bodyA.isMerging = true; bodyB.isMerging = true;

                const currentLevel = bodyA.level;
                const nextLevel = currentLevel + 1;

                if (nextLevel < BALLS.length) {
                    const lowerBody = bodyA.position.y > bodyB.position.y ? bodyA : bodyB;
                    const higherBody = bodyA.position.y > bodyB.position.y ? bodyB : bodyA;
                    
                    const midX = (bodyA.position.x + bodyB.position.x) / 2;
                    const midY = (lowerBody.position.y * 0.75 + higherBody.position.y * 0.25);
                    const newBallInfo = BALLS[nextLevel];

                    const scoreGained = (nextLevel + 1) * 15;
                    updateScore(scoreGained);
                    spawnFloatingText(midX, midY, `+${scoreGained}`, '#ff5252');
                    spawnParticles(midX, midY, newBallInfo.color, 20 + nextLevel * 5);

                    const newBody = Bodies.circle(midX, midY, newBallInfo.radius, {
                        restitution: 0.25, friction: 0.5, frictionAir: 0.015,
                        density: 0.005 + (nextLevel * 0.001),
                        render: { visible: false }, 
                        label: 'circle', level: nextLevel, isMerging: false, renderScale: 0.1 
                    });

                    Composite.remove(world, [bodyA, bodyB]);
                    Composite.add(world, newBody);
                }
            }
        });
    });

    Events.on(engine, 'afterUpdate', () => {
        if (isGameOver) return;
        const bodies = Composite.allBodies(world);
        for (let i = 0; i < bodies.length; i++) {
            const body = bodies[i];
            if (body.renderScale !== undefined && body.renderScale < 1) {
                body.renderScale += (1.05 - body.renderScale) * 0.15; 
            }
            if (body.label === 'circle' && (body.position.y - BALLS[body.level].radius) < GAME_OVER_LINE_Y) {
                if (Math.abs(body.velocity.y) < 0.1 && Math.abs(body.velocity.x) < 0.1 && body.renderScale >= 1) {
                    triggerGameOver(); break;
                }
            }
        }
    });

    // --- 6. æ¸²æŸ“ (ç•«å¸ƒç´°ç¯€) ---
    Events.on(render, 'afterRender', () => {
        const context = render.context;
        const bodies = Composite.allBodies(world);
        context.textAlign = 'center'; context.textBaseline = 'middle';
        
        bodies.forEach(body => {
            if (body.label === 'circle' && body.level !== undefined) {
                const ballInfo = BALLS[body.level];
                const scale = body.renderScale || 1;
                
                context.save();
                context.translate(body.position.x, body.position.y);
                context.scale(scale, scale);
                context.rotate(body.angle);

                context.beginPath(); context.arc(0, 0, ballInfo.radius, 0, 2 * Math.PI);
                context.fillStyle = ballInfo.color; context.fill();
                context.lineWidth = 3; context.strokeStyle = 'rgba(255,255,255,0.4)'; context.stroke();
                
                context.beginPath(); context.arc(0, 0, ballInfo.radius - 2, 0, 2 * Math.PI);
                context.lineWidth = 4; context.strokeStyle = 'rgba(0,0,0,0.08)'; context.stroke();

                context.font = `bold ${ballInfo.radius * 1.1}px Arial`;
                context.fillStyle = '#000'; context.fillText(ballInfo.emoji, 0, ballInfo.radius * 0.05);
                context.restore();
            }
        });

        particles.forEach(p => {
            p.x += p.vx; p.y += p.vy; p.vy += 0.5; p.life -= 0.03;
            if (p.life > 0) {
                context.globalAlpha = p.life; context.fillStyle = p.color;
                context.beginPath(); context.arc(p.x, p.y, p.size, 0, 2 * Math.PI); context.fill();
            }
        });
        particles = particles.filter(p => p.life > 0);
        context.globalAlpha = 1.0;

        floatingTexts.forEach(ft => {
            ft.y += ft.vy; ft.life -= 0.02;
            if (ft.life > 0) {
                context.globalAlpha = ft.life; context.font = 'bold 24px Arial';
                context.fillStyle = ft.color; context.strokeStyle = '#fff'; context.lineWidth = 3;
                context.strokeText(ft.text, ft.x, ft.y); context.fillText(ft.text, ft.x, ft.y);
            }
        });
        floatingTexts = floatingTexts.filter(ft => ft.life > 0);
        context.globalAlpha = 1.0;

        context.beginPath(); context.moveTo(0, GAME_OVER_LINE_Y); context.lineTo(GAME_WIDTH, GAME_OVER_LINE_Y);
        context.strokeStyle = 'rgba(255, 100, 100, 0.6)'; context.lineWidth = 3; context.setLineDash([15, 10]); context.stroke(); context.setLineDash([]); 

        // ã€ä¿®æ”¹ã€‘ä¸ç®¡æœ‰æ²’æœ‰é»æ“Šï¼Œæ°¸é é¡¯ç¤ºä¸Šæ–¹å¾…æ‰è½çš„æ°´æœï¼
        if (canDrop && !isGameOver) {
            const ballInfo = BALLS[currentBallLevel];
            // SafeX å·²ç¶“é™åˆ¶äº†æ°´æœçµ•å°ä¸æœƒè¶…å‡ºå·¦å³ç‰†å£
            const safeX = Math.max(ballInfo.radius, Math.min(GAME_WIDTH - ballInfo.radius, logicalMouseX));
            
            context.globalAlpha = 0.8;
            context.beginPath(); context.arc(safeX, DROP_Y, ballInfo.radius, 0, 2 * Math.PI);
            context.fillStyle = ballInfo.color; context.fill();
            context.lineWidth = 2; context.strokeStyle = '#fff'; context.stroke();
            context.font = `${ballInfo.radius * 1.1}px Arial`; context.fillText(ballInfo.emoji, safeX, DROP_Y + (ballInfo.radius * 0.05));
            context.globalAlpha = 1.0;
            
            context.beginPath(); context.moveTo(safeX, DROP_Y + ballInfo.radius); context.lineTo(safeX, GAME_HEIGHT);
            context.strokeStyle = 'rgba(255, 255, 255, 0.7)'; context.lineWidth = 2; context.setLineDash([8, 8]); context.stroke(); context.setLineDash([]);
        }
    });

    // --- 7. ã€çµ‚æ¥µè¼¸å…¥æ§åˆ¶ã€‘ç¶å®šæ•´å€‹ documentï¼Œæ”¯æ´é‚Šç•Œå¤–å®¹éŒ¯èˆ‡æ°¸é è·Ÿéš¨ ---
    const canvasEl = render.canvas;

    function updateLogicalX(e) {
        if (isGameOver) return;
        const rect = canvasEl.getBoundingClientRect();
        // PointerEvent ç›´æ¥å…§å»º clientXï¼Œç„¡ç¸«æ”¯æ´æ»‘é¼ èˆ‡è§¸æ§
        const scaleX = GAME_WIDTH / rect.width;
        logicalMouseX = (e.clientX - rect.left) * scaleX;
    }

    // ç›£è½å…¨è¢å¹•æ»‘å‹• (ä¿ç•™ PC æ»‘é¼ æ°¸é è·Ÿéš¨çš„é«”é©—)
    document.addEventListener('pointermove', (e) => {
        updateLogicalX(e);
    });

    document.addEventListener('pointerdown', (e) => {
        // é¿å…é»æ“Š UI è§¸ç™¼æ‰è½
        if (e.target.closest('#restart-btn') || e.target.closest('#guide-panel') || e.target.closest('#top-ui-bar')) return;
        if (!canDrop || isGameOver) return;
        isAiming = true;
        updateLogicalX(e);
    });

    document.addEventListener('pointerup', (e) => {
        if (!isAiming || !canDrop || isGameOver) return;
        updateLogicalX(e); 
        isAiming = false;
        dropBall(); // æ”¾é–‹æ‰‹æŒ‡æ‰æ‰è½ï¼
    });
    
    document.addEventListener('pointercancel', () => { isAiming = false; });
    document.getElementById('restart-btn').addEventListener('click', resetGame);

    nextBallLevel = getRandomSpawnLevel();
    prepareNextBall();

</script>
</body>
</html>