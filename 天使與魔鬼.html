<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤©ä½¿èˆ‡é­”é¬¼ï¼šå…¨æ¨¡å¼åšå¼ˆ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap');
        
        body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: #0f172a;
            color: #e2e8f0;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: radial-gradient(circle at center, #1e293b 0%, #020617 100%);
        }

        canvas {
            box-shadow: 0 0 80px rgba(0, 0, 0, 0.6);
            border-radius: 16px;
            cursor: pointer; /* é è¨­æŒ‡æ¨™ */
        }
        
        /* æ ¹æ“šæ¨¡å¼æ”¹è®Šæ¸¸æ¨™ */
        .cursor-dig { cursor: crosshair !important; }
        .cursor-move { cursor: pointer !important; }

        .ui-overlay {
            position: absolute;
            pointer-events: none;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 24px;
            box-sizing: border-box;
        }

        .hud-panel {
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            padding: 16px 24px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.2);
            pointer-events: auto;
            min-width: 220px;
            transition: transform 0.2s ease;
        }

        .hud-panel:hover {
            transform: translateY(-2px);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .status-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 99px;
            overflow: hidden;
            margin-top: 8px;
            position: relative;
        }

        .energy-fill {
            height: 100%;
            background: linear-gradient(90deg, #fcd34d, #f59e0b);
            transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 10px rgba(251, 191, 36, 0.5);
        }
        
        .apple-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #34d399, #10b981);
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(52, 211, 153, 0.4);
        }

        /* Modal Styles */
        .modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(8px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 50;
            pointer-events: auto;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease;
        }

        .modal.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: linear-gradient(145deg, #1e293b, #0f172a);
            padding: 40px;
            border-radius: 24px;
            text-align: center;
            max-width: 600px;
            width: 90%;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 50px rgba(0,0,0,0.6);
            transform: scale(0.95);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .modal.active .modal-content {
            transform: scale(1);
        }

        /* Mode Selection Cards */
        .mode-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .mode-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 20px 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .mode-card:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-5px);
            border-color: rgba(255, 255, 255, 0.3);
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        }

        .mode-icon {
            font-size: 3rem;
            margin-bottom: 10px;
            display: block;
        }

        .mode-title {
            font-weight: bold;
            color: #fff;
            margin-bottom: 5px;
            display: block;
        }

        .mode-desc {
            font-size: 0.8rem;
            color: #94a3b8;
            line-height: 1.4;
        }

        .btn {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: white;
            padding: 14px 40px;
            border-radius: 12px;
            font-weight: bold;
            font-size: 1.1rem;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 24px;
            box-shadow: 0 4px 15px rgba(37, 99, 235, 0.3);
        }
        
        .btn:hover { transform: translateY(-2px); filter: brightness(1.1); }
        
        .btn-danger {
            background: linear-gradient(135deg, #ef4444, #b91c1c);
            box-shadow: 0 4px 15px rgba(220, 38, 38, 0.3);
        }
        
        .btn-secondary {
            background: #475569;
            box-shadow: none;
        }

        .floating-text {
            position: absolute;
            font-weight: bold;
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
        }

        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-40px) scale(1.2); opacity: 0; }
        }
        
        /* Turn Indicator */
        .turn-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: bold;
            margin-bottom: 8px;
            opacity: 0;
            transform: scale(0.9);
            transition: all 0.3s ease;
        }
        .turn-badge.active {
            opacity: 1;
            transform: scale(1);
        }
        .turn-angel { background: rgba(59, 130, 246, 0.2); color: #60a5fa; border: 1px solid #3b82f6; }
        .turn-devil { background: rgba(239, 68, 68, 0.2); color: #f87171; border: 1px solid #ef4444; }

    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="effects-layer" class="absolute top-0 left-0 w-full h-full pointer-events-none overflow-hidden"></div>

        <div class="ui-overlay">
            <!-- é ‚éƒ¨è³‡è¨Š -->
            <div class="flex flex-col md:flex-row justify-between w-full max-w-5xl mx-auto items-start gap-4">
                
                <!-- å·¦å´ï¼šç‹€æ…‹ -->
                <div class="hud-panel">
                    <h2 class="text-xs font-bold text-blue-400 tracking-wider uppercase mb-3">GAME STATUS</h2>
                    
                    <!-- å›åˆæç¤º -->
                    <div id="turn-indicator-angel" class="turn-badge turn-angel">ğŸ‘¼ å¤©ä½¿å›åˆ</div>
                    <div id="turn-indicator-devil" class="turn-badge turn-devil">ğŸ˜ˆ é­”é¬¼å›åˆ</div>

                    <div class="flex justify-between items-center mb-4 mt-2">
                        <div class="flex items-center gap-2">
                            <span id="k-icon" class="text-2xl">ğŸ‘¼</span>
                            <div>
                                <div class="text-xs text-gray-400">å¤©ä½¿å‹æ…‹</div>
                                <div id="k-value" class="text-sm font-bold text-white">æ­¥è¡Œ (K=1)</div>
                            </div>
                        </div>
                    </div>

                    <div class="space-y-3">
                        <div>
                            <div class="flex justify-between text-xs text-gray-400 mb-1">
                                <span>è®Šèº«èƒ½é‡</span>
                                <span id="energy-text" class="text-yellow-400">0 / 4</span>
                            </div>
                            <div class="status-bar">
                                <div id="energy-bar" class="energy-fill" style="width: 0%"></div>
                            </div>
                        </div>

                        <div>
                            <div class="flex justify-between text-xs text-gray-400 mb-1">
                                <span>ä¸‹é¡†è˜‹æœç”Ÿæˆ</span>
                                <span id="apple-spawn-text" class="text-emerald-400">20 æ­¥</span>
                            </div>
                            <div class="status-bar bg-gray-700">
                                <div id="spawn-bar" class="apple-progress-fill" style="width: 0%"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- å³å´ï¼šæ¨¡å¼èˆ‡åˆ†æ•¸ -->
                <div class="hud-panel text-right flex flex-col items-end">
                    <h2 class="text-xs font-bold text-purple-400 tracking-wider uppercase mb-1" id="mode-display">MODE</h2>
                    <div class="flex items-baseline justify-end gap-2 mb-2">
                        <span class="text-5xl font-bold text-white tracking-tight" id="score">0</span>
                        <span class="text-xs text-gray-400 font-bold">ROUNDS</span>
                    </div>
                    
                    <!-- èªè¼¸æŒ‰éˆ• -->
                    <button onclick="showSurrenderConfirm()" class="mt-2 text-xs bg-red-900/50 hover:bg-red-800 text-red-200 py-1 px-3 rounded border border-red-800/50 transition-colors flex items-center gap-1">
                        ğŸ³ï¸ èªè¼¸
                    </button>
                </div>
            </div>

            <!-- åº•éƒ¨åœ–ä¾‹ -->
            <div class="w-full flex justify-center pb-4">
                <div class="hud-panel flex gap-4 backdrop-blur-md">
                    <div class="legend-item"><span class="legend-icon">ğŸ‘¼</span> å¤©ä½¿</div>
                    <div class="legend-item"><span class="legend-icon">ğŸ</span> è˜‹æœ</div>
                    <div class="legend-item"><span class="legend-icon">ğŸ§±</span> è·¯éšœ</div>
                </div>
            </div>
        </div>

        <!-- Start Modal (æ¨¡å¼é¸æ“‡) -->
        <div id="startModal" class="modal active">
            <div class="modal-content relative">
                <h1 class="text-3xl font-bold mb-2 text-white">é¸æ“‡éŠæˆ²æ¨¡å¼</h1>
                <p class="text-gray-400 text-sm mb-6">å¤©ä½¿èˆ‡é­”é¬¼ï¼šåº·å¨åšå¼ˆ</p>
                
                <div class="mode-grid">
                    <!-- æ¨¡å¼ 1: å¤©ä½¿ -->
                    <div class="mode-card" onclick="startGame('ANGEL')">
                        <span class="mode-icon">ğŸ‘¼</span>
                        <span class="mode-title">æˆ‘æ˜¯å¤©ä½¿</span>
                        <span class="mode-desc">ç¶“å…¸æ¨¡å¼ã€‚èº²é¿ AI é­”é¬¼çš„åŒ…åœï¼Œæ”¶é›†è˜‹æœç”Ÿå­˜ã€‚</span>
                    </div>

                    <!-- æ¨¡å¼ 2: é­”é¬¼ -->
                    <div class="mode-card" onclick="startGame('DEVIL')">
                        <span class="mode-icon">ğŸ˜ˆ</span>
                        <span class="mode-title">æˆ‘æ˜¯é­”é¬¼</span>
                        <span class="mode-desc">æ‰®æ¼”çµäººã€‚é»æ“ŠæŒ–æ´ï¼Œé‹ç”¨æ™ºæ…§å›°ä½ AI å¤©ä½¿ã€‚</span>
                    </div>

                    <!-- æ¨¡å¼ 3: é›™äºº -->
                    <div class="mode-card" onclick="startGame('PVP')">
                        <span class="mode-icon">âš”ï¸</span>
                        <span class="mode-title">é›™äººå°æˆ°</span>
                        <span class="mode-desc">ç†±åº§æ¨¡å¼ã€‚P1 å¤©ä½¿ç§»å‹•ï¼ŒP2 é­”é¬¼æŒ–æ´ã€‚</span>
                    </div>
                </div>

               <a href="./index.html" class="btn btn-secondary w-full mt-8 block text-center" style="text-decoration: none;">è¿”å›</a>           </div>
        </div>

        <!-- Surrender Confirmation Modal -->
        <div id="surrenderModal" class="modal">
            <div class="modal-content" style="max-width: 360px;">
                <h2 class="text-2xl font-bold mb-4 text-white">ç¢ºå®šè¦èªè¼¸å—ï¼Ÿ</h2>
                <p class="text-gray-400 mb-8">ç›®å‰çš„é€²åº¦å°‡æœƒéºå¤±ï¼Œä¸¦å›åˆ°ä¸»é¸å–®ã€‚</p>
                
                <div class="flex gap-4 justify-center">
                    <button class="btn btn-secondary" style="margin-top: 0;" onclick="closeSurrenderConfirm()">å–æ¶ˆ</button>
                    <button class="btn btn-danger" style="margin-top: 0;" onclick="confirmSurrender()">ç¢ºå®šèªè¼¸</button>
                </div>
            </div>
        </div>

        <!-- Game Over Modal -->
        <div id="gameOverModal" class="modal">
            <div class="modal-content">
                <div class="text-6xl mb-4" id="end-icon">ğŸ</div>
                <h1 class="text-3xl font-bold mb-2 text-white" id="end-title">éŠæˆ²çµæŸ</h1>
                <p class="text-gray-400 mb-8" id="end-desc">...</p>
                
                <div class="grid grid-cols-2 gap-4 mb-8">
                    <div class="bg-slate-800/80 p-4 rounded-xl border border-white/5">
                        <div class="text-xs text-gray-400 uppercase tracking-wider mb-1">ç”Ÿå­˜å›åˆ</div>
                        <div class="text-3xl font-bold text-white" id="final-score">0</div>
                    </div>
                    <div class="bg-slate-800/80 p-4 rounded-xl border border-white/5">
                        <div class="text-xs text-gray-400 uppercase tracking-wider mb-1">æ”¶é›†è˜‹æœ</div>
                        <div class="text-3xl font-bold text-yellow-400" id="final-apples">0</div>
                    </div>
                </div>

                <button class="btn w-full" onclick="showStartScreen()">è¿”å›ä¸»é¸å–®</button>
            </div>
        </div>
    </div>

    <script>
        // --- åƒæ•¸ ---
        const GRID_SIZE = 46;     
        const MAX_ENERGY = 4;
        const SPAWN_INTERVAL = 20;
        const INITIAL_APPLES = 3;
        
        let canvas, ctx;
        let effectsLayer;
        
        // --- éŠæˆ²ç‹€æ…‹ ---
        let gameState = {
            mode: 'ANGEL', // 'ANGEL', 'DEVIL', 'PVP'
            angel: { x: 0, y: 0 },
            k: 1, 
            energy: 0,
            turn: 0,
            stepCount: 0,
            applesEaten: 0,
            blockedCells: new Set(),
            apples: [], 
            isGameOver: false,
            lastBlocked: null,
            // PVP ç”¨
            isAngelTurn: true 
        };

        window.onload = () => {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            effectsLayer = document.getElementById('effects-layer');
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            canvas.addEventListener('mousedown', handleInput);
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                handleInput(e.touches[0]);
            }, {passive: false});

            render();
        };

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (!gameState.isGameOver && gameState.turn > 0) render();
        }

        function showStartScreen() {
            document.getElementById('startModal').classList.add('active');
            document.getElementById('gameOverModal').classList.remove('active');
            document.getElementById('surrenderModal').classList.remove('active');
        }
        
        // --- èªè¼¸åŠŸèƒ½ ---
        function showSurrenderConfirm() {
            if (gameState.isGameOver) return; // å·²ç¶“çµæŸå°±ä¸ç”¨èªè¼¸äº†
            document.getElementById('surrenderModal').classList.add('active');
        }

        function closeSurrenderConfirm() {
            document.getElementById('surrenderModal').classList.remove('active');
        }

        function confirmSurrender() {
            closeSurrenderConfirm();
            showStartScreen();
        }

        function startGame(mode) {
            gameState = {
                mode: mode,
                angel: { x: 0, y: 0 },
                k: 1,
                energy: 0,
                turn: 1,
                stepCount: 0,
                applesEaten: 0,
                blockedCells: new Set(),
                apples: [],
                isGameOver: false,
                lastBlocked: null,
                isAngelTurn: true 
            };

            // è¨­å®šæ¸¸æ¨™
            if (mode === 'DEVIL') {
                canvas.className = 'cursor-dig';
            } else {
                canvas.className = 'cursor-move';
            }

            effectsLayer.innerHTML = '';
            spawnApples(INITIAL_APPLES);

            document.getElementById('startModal').classList.remove('active');
            document.getElementById('gameOverModal').classList.remove('active');
            document.getElementById('surrenderModal').classList.remove('active');
            
            // UI æ–‡å­—è¨­å®š
            let modeName = "å¤©ä½¿æ¨¡å¼";
            if (mode === 'DEVIL') modeName = "é­”é¬¼æ¨¡å¼";
            if (mode === 'PVP') modeName = "é›™äººå°æˆ°";
            document.getElementById('mode-display').innerText = modeName;

            updateUI();
            render();
        }

        function gameOver(reason) {
            gameState.isGameOver = true;
            document.getElementById('final-score').innerText = gameState.turn;
            document.getElementById('final-apples').innerText = gameState.applesEaten;
            
            let title = "";
            let desc = "";
            let icon = "";

            if (gameState.mode === 'DEVIL') {
                title = "ç‹©çµæˆåŠŸï¼";
                desc = "ä½ æˆåŠŸå›°ä½äº† AI å¤©ä½¿ã€‚";
                icon = "ğŸ˜ˆ";
            } else if (gameState.mode === 'PVP') {
                title = "é­”é¬¼ç²å‹";
                desc = "å¤©ä½¿ç„¡è·¯å¯é€ƒäº†ã€‚";
                icon = "ğŸ†";
            } else {
                title = "è¢«æ•ç²";
                desc = "é­”é¬¼é åˆ¤äº†ä½ çš„å‹•ä½œ...";
                icon = "ğŸ’€";
            }

            document.getElementById('end-title').innerText = title;
            document.getElementById('end-desc').innerText = desc;
            document.getElementById('end-icon').innerText = icon;

            setTimeout(() => {
                document.getElementById('gameOverModal').classList.add('active');
            }, 800);
        }

        // --- æ ¸å¿ƒè¼¸å…¥è™•ç† (åˆ†æµ) ---
        function handleInput(e) {
            if (gameState.isGameOver) return;
            // å¦‚æœèªè¼¸è¦–çª—é–‹è‘—ï¼Œä¸è™•ç†é»æ“Š
            if (document.getElementById('surrenderModal').classList.contains('active')) return;

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            const worldX = Math.floor((mouseX - centerX + (gameState.angel.x * GRID_SIZE) + (GRID_SIZE/2)) / GRID_SIZE);
            const worldY = Math.floor((mouseY - centerY + (gameState.angel.y * GRID_SIZE) + (GRID_SIZE/2)) / GRID_SIZE);

            if (gameState.mode === 'ANGEL') {
                // ç©å®¶æ“ä½œå¤©ä½¿ï¼Œç§»å‹•å®Œå¾Œ AI é­”é¬¼å‹•
                let moved = performAngelMove(worldX, worldY);
                if (moved) {
                    if (checkDeadEnd()) { gameOver(); return; }
                    runDevilAI(); // AI é­”é¬¼
                    endTurn();
                }
            } 
            else if (gameState.mode === 'DEVIL') {
                // ç©å®¶æ“ä½œé­”é¬¼ï¼ŒæŒ–å®Œæ´å¾Œ AI å¤©ä½¿å‹•
                // é­”é¬¼ä¸èƒ½æŒ–å¤©ä½¿è…³ä¸‹ï¼Œä¹Ÿä¸èƒ½æŒ–è˜‹æœ
                let dug = performDevilAction(worldX, worldY);
                if (dug) {
                    if (checkDeadEnd()) { gameOver(); return; } // ç©å®¶æŒ–å®Œç›´æ¥è´
                    runAngelAI(); // AI å¤©ä½¿
                    endTurn();
                }
            } 
            else if (gameState.mode === 'PVP') {
                // é›™äººè¼ªæµ
                if (gameState.isAngelTurn) {
                    let moved = performAngelMove(worldX, worldY);
                    if (moved) {
                        gameState.isAngelTurn = false;
                        updateUI();
                        if (checkDeadEnd()) { gameOver(); return; }
                    }
                } else {
                    let dug = performDevilAction(worldX, worldY);
                    if (dug) {
                        gameState.isAngelTurn = true;
                        endTurn(); // å…©äººéƒ½å‹•å®Œç®—ä¸€å›åˆ
                    }
                }
            }
        }

        // AI å¤©ä½¿ (æ–°åŠŸèƒ½ - å„ªåŒ–ç‰ˆ V2)
        function runAngelAI() {
            let range = gameState.k;
            let possibleMoves = [];

            // 0. åˆ†ææˆ°å ´ï¼šè¨ˆç®—å‘¨åœè·¯éšœçš„ã€Œé‡å¿ƒã€ (Center of blocked mass)
            // é€™èƒ½å¹«åŠ©å¤©ä½¿åˆ¤æ–·å“ªé‚Šæ˜¯ã€Œç‰†å£å¯†é›†å€ã€ï¼Œç„¶å¾Œå¾€åæ–¹å‘è·‘
            let blockCenter = {x:0, y:0, count:0};
            let scanRadius = 6;
            for(let dx=-scanRadius; dx<=scanRadius; dx++){
                for(let dy=-scanRadius; dy<=scanRadius; dy++){
                    if(gameState.blockedCells.has(`${gameState.angel.x+dx},${gameState.angel.y+dy}`)){
                        blockCenter.x += dx;
                        blockCenter.y += dy;
                        blockCenter.count++;
                    }
                }
            }

            // 1. æƒææ‰€æœ‰å¯è¡Œç§»å‹•
            for (let dx = -range; dx <= range; dx++) {
                for (let dy = -range; dy <= range; dy++) {
                    if (dx === 0 && dy === 0) continue;
                    let nx = gameState.angel.x + dx;
                    let ny = gameState.angel.y + dy;
                    
                    if (!gameState.blockedCells.has(`${nx},${ny}`)) {
                        let score = 0;
                        
                        // --- A. ç”Ÿå­˜è©•ä¼° (Survival) ---
                        // é åˆ¤ï¼šèµ°éå»ä¹‹å¾Œï¼Œé‚£å€‹æ ¼å­å‘¨åœé‚„æœ‰å¹¾æ ¼æ˜¯ç©ºçš„ï¼Ÿ
                        let futureFreedom = 0;
                        for(let idx = -1; idx <= 1; idx++){
                            for(let idy = -1; idy <= 1; idy++){
                                if(idx===0 && idy===0) continue;
                                if(!gameState.blockedCells.has(`${nx+idx},${ny+idy}`)) futureFreedom++;
                            }
                        }

                        // åš´é‡æ‡²ç½°æ­»è·¯
                        if (futureFreedom === 0) score -= 10000; // è‡ªæ®ºè¡Œç‚º
                        else if (futureFreedom === 1) score -= 500; // æ­»å··å­
                        else if (futureFreedom === 2) score -= 100; // çª„å··é¢¨éšª
                        else score += futureFreedom * 10; // è¶Šé–‹é—Šè¶Šå¥½

                        // --- B. è˜‹æœèª˜å›  (Greed) ---
                        let isApple = gameState.apples.some(a => a.x === nx && a.y === ny);
                        if (isApple) {
                            score += 5000; // çµ•å°å„ªå…ˆ
                        } else {
                            // å°‹æ‰¾æœ€è¿‘çš„è˜‹æœ
                            let minAppleDist = 999;
                            gameState.apples.forEach(a => {
                                let d = Math.max(Math.abs(a.x - nx), Math.abs(a.y - ny));
                                if(d < minAppleDist) minAppleDist = d;
                            });
                            // è·é›¢è¶Šè¿‘åˆ†æ•¸è¶Šé«˜ (æ¬Šé‡é©ä¸­ï¼Œé¿å…ç‚ºäº†è˜‹æœé€æ­»)
                            score += (30 - minAppleDist) * 15; 
                        }

                        // --- C. é é›¢åŒ…åœç¶² (Escape) ---
                        // å¦‚æœå‘¨åœæœ‰ç‰†ï¼Œè¨ˆç®—ç§»å‹•å‘é‡èˆ‡ç‰†å£é‡å¿ƒçš„é—œä¿‚
                        if (blockCenter.count > 0) {
                            // ç°¡å–®å‘é‡è¨ˆç®—ï¼šæˆ‘å€‘å¸Œæœ› (dx, dy) å’Œ (blockCenter) æ˜¯åå‘çš„
                            // ä½¿ç”¨é»ç©ï¼šè‹¥ç‚ºæ­£ä»£è¡¨å¾€ç‰†å£èµ°ï¼Œè‹¥ç‚ºè² ä»£è¡¨é é›¢ç‰†å£
                            let avgX = blockCenter.x / blockCenter.count;
                            let avgY = blockCenter.y / blockCenter.count;
                            let dotProduct = dx * avgX + dy * avgY;
                            
                            score -= dotProduct * 20; // å¾€ç‰†å£èµ°æ‰£åˆ†ï¼Œé é›¢åŠ åˆ†
                        }

                        // --- D. æˆ°è¡“ç§»å‹• (K=2) ---
                        // å¦‚æœæœƒé£›ï¼Œå„ªå…ˆè·³é ä¸€é»ï¼Œæ‹‰é–‹èˆ‡é­”é¬¼çš„è·é›¢
                        if (gameState.k === 2) {
                            let dist = Math.max(Math.abs(dx), Math.abs(dy));
                            if (dist === 2) score += 60; // é¼“å‹µå¤§è·³èº
                        }
                        
                        // --- E. é é›¢ä¸Šä¸€æ¬¡é­”é¬¼æŒ–æ´çš„åœ°æ–¹ ---
                        if (gameState.lastBlocked) {
                            let distToLast = Math.max(Math.abs(nx - gameState.lastBlocked.x), Math.abs(ny - gameState.lastBlocked.y));
                            score += distToLast * 5;
                        }

                        possibleMoves.push({x: nx, y: ny, score: score});
                    }
                }
            }

            if (possibleMoves.length > 0) {
                // æ’åºï¼šåˆ†æ•¸é«˜çš„åœ¨å‰
                possibleMoves.sort((a, b) => b.score - a.score);
                
                // èè‹±æ±ºç­–ï¼šåªåœ¨å‰ 2 åä¸­é¸æ“‡ï¼Œå¤§å¹…æ¸›å°‘éš¨æ©Ÿå¤±èª¤
                let topCount = Math.min(2, possibleMoves.length);
                let choiceIdx = 0;
                
                // 90% æ©Ÿç‡é¸æœ€ä½³è§£ï¼Œ10% æ©Ÿç‡é¸æ¬¡ä½³è§£ (æ¨¡æ“¬ä¸€é»é»çŒ¶è±«)
                if (Math.random() > 0.9 && topCount > 1) {
                    choiceIdx = 1;
                }

                let move = possibleMoves[choiceIdx];
                performAngelMove(move.x, move.y);
            } else {
                // çœŸçš„ç„¡è·¯å¯èµ°ï¼Œéš¨ä¾¿æ’ä¸€å€‹è§¸ç™¼ Game Over
                // é€™è£¡ä¸ç”¨ç‰¹åˆ¥å¯«ï¼Œæœƒåœ¨ä¸‹ä¸€æ¬¡ loop è¢« checkDeadEnd æŠ“åˆ°
            }
        }

        // --- å‹•ä½œé‚è¼¯ ---

        // å¤©ä½¿ç§»å‹• (Return true if success)
        function performAngelMove(tx, ty) {
            if (tx === gameState.angel.x && ty === gameState.angel.y) return false;

            let dx = Math.abs(tx - gameState.angel.x);
            let dy = Math.abs(ty - gameState.angel.y);
            let dist = Math.max(dx, dy);

            if (dist > gameState.k) return false;
            if (gameState.blockedCells.has(`${tx},${ty}`)) {
                showFloatingText(canvas.width/2 + (tx-gameState.angel.x)*GRID_SIZE, canvas.height/2 + (ty-gameState.angel.y)*GRID_SIZE, "ğŸš«", "#ef4444");
                return false;
            }

            // Execute Move
            gameState.angel.x = tx;
            gameState.angel.y = ty;
            gameState.stepCount++; 

            // Check Apple
            let appleIndex = gameState.apples.findIndex(a => a.x === tx && a.y === ty);
            if (appleIndex !== -1) {
                gameState.apples.splice(appleIndex, 1);
                gameState.applesEaten++;
                gameState.energy = MAX_ENERGY;
                gameState.k = 2;
                showFloatingText(canvas.width/2, canvas.height/2, "Power UP! ğŸ§š", "#facc15");
            } else {
                if (gameState.k > 1) {
                    gameState.energy--;
                    if (gameState.energy <= 0) {
                        gameState.energy = 0;
                        gameState.k = 1;
                        showFloatingText(canvas.width/2, canvas.height/2, "Energy Depleted â¬‡ï¸", "#94a3b8");
                    }
                }
            }

            // Spawn Logic
            if (gameState.stepCount % SPAWN_INTERVAL === 0) {
                spawnApples(1);
            }
            return true;
        }

        // é­”é¬¼æŒ–æ´ (Return true if success)
        function performDevilAction(tx, ty) {
            // ä¸èƒ½æŒ–å¤©ä½¿è…³ä¸‹
            if (tx === gameState.angel.x && ty === gameState.angel.y) {
                showFloatingText(canvas.width/2 + (tx-gameState.angel.x)*GRID_SIZE, canvas.height/2 + (ty-gameState.angel.y)*GRID_SIZE, "ğŸ›¡ï¸", "#3b82f6");
                return false;
            }
            // ä¸èƒ½æŒ–å·²ç¶“æŒ–éçš„
            if (gameState.blockedCells.has(`${tx},${ty}`)) return false;

            // è¦å‰‡ï¼šä¸èƒ½æŒ–è˜‹æœ
            let hasApple = gameState.apples.some(a => a.x === tx && a.y === ty);
            if (hasApple) {
                showFloatingText(canvas.width/2 + (tx-gameState.angel.x)*GRID_SIZE, canvas.height/2 + (ty-gameState.angel.y)*GRID_SIZE, "ğŸ Protected", "#34d399");
                return false;
            }

            gameState.blockedCells.add(`${tx},${ty}`);
            gameState.lastBlocked = {x: tx, y: ty};
            return true;
        }

        function endTurn() {
            gameState.turn++;
            updateUI();
            if (checkDeadEnd()) {
                gameOver();
            }
            render();
        }

        // --- AI ç³»çµ± ---

        // AI é­”é¬¼ (åŸç‰ˆé‚è¼¯)
        function runDevilAI() {
            let possibleMoves = [];
            let scanRange = 2; 

            for (let dx = -scanRange; dx <= scanRange; dx++) {
                for (let dy = -scanRange; dy <= scanRange; dy++) {
                    if (dx === 0 && dy === 0) continue;
                    let nx = gameState.angel.x + dx;
                    let ny = gameState.angel.y + dy;
                    
                    let hasApple = gameState.apples.some(a => a.x === nx && a.y === ny);
                    if (hasApple) continue;

                    if (!gameState.blockedCells.has(`${nx},${ny}`)) {
                        let value = 0;
                        // Freedom
                        let freedom = 0;
                        for(let idx = -1; idx <= 1; idx++){
                            for(let idy = -1; idy <= 1; idy++){
                                if(idx===0 && idy===0) continue;
                                if(!gameState.blockedCells.has(`${nx+idx},${ny+idy}`)) freedom++;
                            }
                        }
                        value += freedom * 2;
                        // Apple Proximity
                        gameState.apples.forEach(a => {
                            let dist = Math.max(Math.abs(a.x - nx), Math.abs(a.y - ny));
                            if(dist < 5) value += (6 - dist) * 3;
                        });
                        // Urgency
                        let distToAngel = Math.max(Math.abs(dx), Math.abs(dy));
                        if(distToAngel === 1) value += 10;
                        if(distToAngel === 2 && gameState.k === 2) value += 8;

                        possibleMoves.push({x: nx, y: ny, score: value});
                    }
                }
            }

            possibleMoves.sort((a, b) => b.score - a.score);
            let target = null;
            if (possibleMoves.length > 0) {
                target = (Math.random() > 0.1 || possibleMoves.length === 1) ? possibleMoves[0] : possibleMoves[1];
            } else {
                // Random fallback
                let range = 4;
                for(let i=0; i<10; i++) {
                     let cx = gameState.angel.x + Math.floor(Math.random()*(range*2+1))-range;
                     let cy = gameState.angel.y + Math.floor(Math.random()*(range*2+1))-range;
                     let isApple = gameState.apples.some(a => a.x === cx && a.y === cy);
                     if((cx!=gameState.angel.x || cy!=gameState.angel.y) && !isApple && !gameState.blockedCells.has(`${cx},${cy}`)) {
                         target = {x: cx, y: cy};
                         break;
                     }
                }
            }

            if (target) {
                gameState.blockedCells.add(`${target.x},${target.y}`);
                gameState.lastBlocked = target;
            }
        }

        // --- è¼”åŠ©å‡½å¼ ---

        function spawnApples(count) {
            let attempts = 0;
            let range = 6 + Math.floor(gameState.turn / 20); 

            while (count > 0 && attempts < 100) {
                let dx = Math.floor(Math.random() * (range * 2 + 1)) - range;
                let dy = Math.floor(Math.random() * (range * 2 + 1)) - range;
                
                if (Math.abs(dx) < 3 && Math.abs(dy) < 3) continue;

                let tx = gameState.angel.x + dx;
                let ty = gameState.angel.y + dy;
                let key = `${tx},${ty}`;

                let exists = gameState.apples.some(a => a.x === tx && a.y === ty);
                if (!exists && !gameState.blockedCells.has(key)) {
                    gameState.apples.push({x: tx, y: ty});
                    count--;
                    if(gameState.turn > 1) showFloatingText(canvas.width/2, canvas.height/4, "New Apple! ğŸ", "#34d399");
                }
                attempts++;
            }
        }

        function checkDeadEnd() {
            let range = gameState.k;
            for (let dx = -range; dx <= range; dx++) {
                for (let dy = -range; dy <= range; dy++) {
                    if (dx === 0 && dy === 0) continue;
                    let nx = gameState.angel.x + dx;
                    let ny = gameState.angel.y + dy;
                    if (!gameState.blockedCells.has(`${nx},${ny}`)) {
                        return false;
                    }
                }
            }
            return true;
        }

        function showFloatingText(x, y, text, color) {
            const el = document.createElement('div');
            el.className = 'floating-text';
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            el.style.color = color;
            el.innerText = text;
            effectsLayer.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }

        function updateUI() {
            document.getElementById('score').innerText = gameState.turn;
            
            const kIcon = gameState.k === 1 ? 'ğŸ‘¼' : 'ğŸ§š';
            const kText = gameState.k === 1 ? 'æ­¥è¡Œæ¨¡å¼ (K=1)' : 'é£›è¡Œæ¨¡å¼ (K=2)';
            document.getElementById('k-icon').innerText = kIcon;
            document.getElementById('k-value').innerText = kText;
            document.getElementById('k-value').className = gameState.k === 1 ? "text-sm font-bold text-gray-300" : "text-sm font-bold text-yellow-400";
            
            document.getElementById('energy-text').innerText = `${gameState.energy} / ${MAX_ENERGY}`;
            let ePct = (gameState.energy / MAX_ENERGY) * 100;
            document.getElementById('energy-bar').style.width = `${ePct}%`;
            
            let steps = gameState.stepCount % SPAWN_INTERVAL;
            let stepsLeft = SPAWN_INTERVAL - steps;
            if(steps === 0 && gameState.stepCount > 0) stepsLeft = SPAWN_INTERVAL;
            document.getElementById('apple-spawn-text').innerText = `${stepsLeft} æ­¥`;
            let sPct = (steps / SPAWN_INTERVAL) * 100;
            document.getElementById('spawn-bar').style.width = `${sPct}%`;

            // æ›´æ–°å›åˆæç¤º (PVP)
            if (gameState.mode === 'PVP') {
                if (gameState.isAngelTurn) {
                    document.getElementById('turn-indicator-angel').classList.add('active');
                    document.getElementById('turn-indicator-devil').classList.remove('active');
                } else {
                    document.getElementById('turn-indicator-angel').classList.remove('active');
                    document.getElementById('turn-indicator-devil').classList.add('active');
                }
            } else if (gameState.mode === 'DEVIL') {
                document.getElementById('turn-indicator-angel').classList.remove('active');
                document.getElementById('turn-indicator-devil').innerText = "ğŸ˜ˆ ä½ æ˜¯é­”é¬¼";
                document.getElementById('turn-indicator-devil').classList.add('active');
            } else {
                document.getElementById('turn-indicator-angel').innerText = "ğŸ‘¼ ä½ æ˜¯å¤©ä½¿";
                document.getElementById('turn-indicator-angel').classList.add('active');
                document.getElementById('turn-indicator-devil').classList.remove('active');
            }
        }

        // --- æ¸²æŸ“ ---
        function render() {
            // Bg
            let g = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, canvas.width);
            g.addColorStop(0, '#1e293b');
            g.addColorStop(1, '#020617');
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const offsetX = centerX - (gameState.angel.x * GRID_SIZE) - (GRID_SIZE/2);
            const offsetY = centerY - (gameState.angel.y * GRID_SIZE) - (GRID_SIZE/2);

            let startCol = Math.floor(-offsetX / GRID_SIZE);
            let endCol = startCol + (canvas.width / GRID_SIZE) + 1;
            let startRow = Math.floor(-offsetY / GRID_SIZE);
            let endRow = startRow + (canvas.height / GRID_SIZE) + 1;

            ctx.lineWidth = 1;
            
            for (let x = startCol; x <= endCol; x++) {
                for (let y = startRow; y <= endRow; y++) {
                    let px = offsetX + x * GRID_SIZE;
                    let py = offsetY + y * GRID_SIZE;

                    ctx.strokeStyle = 'rgba(51, 65, 85, 0.3)';
                    ctx.strokeRect(px, py, GRID_SIZE, GRID_SIZE);

                    let key = `${x},${y}`;

                    if (gameState.blockedCells.has(key)) {
                        ctx.fillStyle = '#450a0a';
                        ctx.fillRect(px, py, GRID_SIZE, GRID_SIZE);
                        ctx.font = `${GRID_SIZE * 0.6}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = 'rgba(255,255,255,0.2)';
                        ctx.fillText('ğŸ§±', px + GRID_SIZE/2, py + GRID_SIZE/2 + 2);
                    }
                }
            }

            let range = gameState.k;
            // åªæœ‰åœ¨å¤©ä½¿å›åˆæˆ–å–®äººå¤©ä½¿æ¨¡å¼ï¼Œæ‰é¡¯ç¤ºå¯ç§»å‹•ç¯„åœï¼Œé¿å…åœ¨ PVP æš´éœ²å¤©ä½¿æ„åœ– (æˆ–è€…éƒ½é¡¯ç¤ºæ–¹ä¾¿æ€è€ƒ)
            // ç‚ºäº†æ–¹ä¾¿éŠç©ï¼Œæˆ‘å€‘çµ±ä¸€é¡¯ç¤ºå¤©ä½¿çš„å¯è¡Œç¯„åœ
            ctx.fillStyle = gameState.k === 1 ? 'rgba(59, 130, 246, 0.1)' : 'rgba(234, 179, 8, 0.1)';
            
            for (let dx = -range; dx <= range; dx++) {
                for (let dy = -range; dy <= range; dy++) {
                    if (dx === 0 && dy === 0) continue;
                    let tx = gameState.angel.x + dx;
                    let ty = gameState.angel.y + dy;
                    
                    if (!gameState.blockedCells.has(`${tx},${ty}`)) {
                        let px = offsetX + tx * GRID_SIZE;
                        let py = offsetY + ty * GRID_SIZE;
                        ctx.fillRect(px + 4, py + 4, GRID_SIZE - 8, GRID_SIZE - 8);
                    }
                }
            }

            for (let apple of gameState.apples) {
                let px = offsetX + apple.x * GRID_SIZE + GRID_SIZE/2;
                let py = offsetY + apple.y * GRID_SIZE + GRID_SIZE/2;
                
                let gradient = ctx.createRadialGradient(px, py, GRID_SIZE/4, px, py, GRID_SIZE/1.5);
                gradient.addColorStop(0, 'rgba(251, 191, 36, 0.4)');
                gradient.addColorStop(1, 'rgba(251, 191, 36, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(px, py, GRID_SIZE/1.5, 0, Math.PI * 2);
                ctx.fill();

                ctx.font = `${GRID_SIZE * 0.7}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = "rgba(0,0,0,0.5)";
                ctx.shadowBlur = 4;
                ctx.fillText('ğŸ', px, py + 2);
                ctx.shadowBlur = 0;
            }

            let cx = centerX;
            let cy = centerY;

            ctx.beginPath();
            let glowColor = gameState.k === 1 ? 'rgba(59, 130, 246, 0.5)' : 'rgba(234, 179, 8, 0.6)';
            let gradient = ctx.createRadialGradient(cx, cy, 5, cx, cy, 25);
            gradient.addColorStop(0, glowColor);
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = gradient;
            ctx.arc(cx, cy, 25, 0, Math.PI * 2);
            ctx.fill();

            let angelIcon = gameState.k === 1 ? 'ğŸ‘¼' : 'ğŸ§š';
            ctx.font = `${GRID_SIZE * 0.8}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            let floatY = Math.sin(Date.now() / 200) * 3; 

            ctx.shadowColor = gameState.k === 1 ? '#60a5fa' : '#fbbf24';
            ctx.shadowBlur = 15;
            ctx.fillText(angelIcon, cx, cy + floatY);
            ctx.shadowBlur = 0;

            if (gameState.lastBlocked) {
                let lpx = offsetX + gameState.lastBlocked.x * GRID_SIZE;
                let lpy = offsetY + gameState.lastBlocked.y * GRID_SIZE;
                
                ctx.strokeStyle = '#ef4444';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(lpx, lpy, GRID_SIZE, GRID_SIZE);
                ctx.setLineDash([]);
            }

            if (!gameState.isGameOver) {
                requestAnimationFrame(render);
            }
        }
    </script>
</body>
</html>